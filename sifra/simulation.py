import numpy as np

from sifra.configuration import Configuration
from sifra.logger import rootLogger
from sifra.modelling.hazard import Hazard
from sifra.scenario import Scenario


class Simulation:

    def __init__(self,configuration_file_path):

        # a variable to store a list of simulation_results


        #think weather copyies of these variable need to be kept this is direct binding very bad practise
        self.config = Configuration(configuration_file_path)
        self.scenario = Scenario(self.config)
        self.infrastructure, algorithm_factory = ingest_model(self.config)
        self.hazard = Hazard(self.config)

        # variable to hold the states of all the components

    #a function to get a single simulation result ie probabilty of components
    #a funtion to loop over different types of hazard values

    # def main_container(self, configuration_file_path):
    #     """
    #     Run a scenario by constructing a facility, and executing a scenario, with
    #     the parameters read from the config file.
    #     :param configuration_file_path: Scenario setting values and the infrastructure configuration file path
    #     :return: None
    #     """
    #
    #     rootLogger.info("Loading scenario config... ")
    #     config = Configuration(configuration_file_path)
    #     rootLogger.info("Done.")
    #
    #
    #     rootLogger.info("constructing scenario... ")
    #     scenario = Scenario(config)
    #     rootLogger.info("Done.")
    #
    #     hazard_level_response = []
    #     for hazard_level in self.hazard.hazard_range:
    #
    #         hazard_level_response.append(infrastructure.expose_to(hazard_level, scenario))
    #
    #         component_damage_state_ind = self.probable_ds_hazard_level(hazard_level, scenario)
    #
    #             run_simulation(infrastructure, hazard_level, sceanario)
    #
    #         print()

def probable_ds_hazard_level( infrastructure, hazard_level, scenario):
    """
    Calculate the probability that being exposed to a hazard level
    will exceed the given damage levels for each component. A monte
    carlo approach is taken by simulating the exposure for the number
    of samples given in the scenario.
    :param hazard_level: Level of the hazard
    :param scenario: Parameters for the scenario
    :return: An array of the probability that each of the damage states were exceeded.
    """
    if scenario.run_context:
        # Use seeding for this test run for reproducibility, the seeding
        # is generated by converting the hazard intensity to an integer
        # after shifting by two decimal places.
        prng = np.random.RandomState(int(hazard_level.hazard_intensity * 100))
    else:
        # seeding was not used
        prng = np.random.RandomState()

    # record the number of elements for use
    num_components = len(infrastructure.components)

    # construct a zeroed numpy array that can contain the number of samples for
    # each element.
    component_damage_state_ind = np.zeros((scenario.num_samples, num_components),
                                          dtype=int)
    # create another numpy array of random uniform [0,1.0) numbers.
    rnd = prng.uniform(size=(scenario.num_samples, num_components))
    rootLogger.debug("Hazard Intensity {}".format(hazard_level.hazard_intensity))
    # iterate through the components
    for index, comp_key in enumerate(sorted(infrastructure.components.keys())):
        component = infrastructure.components[comp_key]
        # use the components expose_to method to retrieve the probabilities
        # of this hazard level exceeding each of the components damage levels

        hazard_intensity = hazard_level.determine_intensity_at(component.get_location())
        component_pe_ds = component.response_algorithm.pe_ds(hazard_intensity)[1:]

        rootLogger.debug("Component {} : pe_ds {}".format(component.component_id,
                                                          component_pe_ds))

        # This little piece of numpy magic calculates the damage level by summing
        # how many damage states were exceeded.
        # Unpacking the calculation:
        # component_pe_ds is usually something like [0.01, 0.12, 0.21, 0.33]
        # rnd[:, index] gives the random numbers created for this component
        # with the first axis (denoted by :) containing the samples for this
        # hazard intensity. The [:, np.newaxis] broadcasts
        # (https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html)
        # each randomn number across the supplied component_pe_ds. If the last two
        # numbers in component_pe_ds are greater than the sample number, the
        # comparison > will return [False, False, True, True]
        # the np.sum will convert this to [1, 1, 0, 0] and return 2. This is the resulting
        # damage level. This will complete the comparison for all of the samples
        # for this component

        component_damage_state_ind[:, index] = \
            np.sum(component_pe_ds > rnd[:, index][:, np.newaxis], axis=1)

    return component_damage_state_ind
